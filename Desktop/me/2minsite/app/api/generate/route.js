import { NextResponse } from "next/server";

// Lazy import to avoid errors before dependency install completes
let JSZipModule = null;
async function getJSZip() {
  if (JSZipModule) return JSZipModule;
  try {
    JSZipModule = (await import("jszip")).default; 
    return JSZipModule;  
  } catch (e) { 
    return null;
  } 
}

// Lazy import Gemini SDK
let GoogleAI = null;
async function getGoogleAI() {
  if (GoogleAI) return GoogleAI;
  try {
    const mod = await import("@google/generative-ai");
    GoogleAI = mod.GoogleGenerativeAI;
    return GoogleAI; 
  } catch (e) {
    return null;
  }
}

function buildFromPrompt(prompt) {
  const safePrompt = String(prompt || "").slice(0, 2000);
  const title = safePrompt ? `${safePrompt}` : "My 2 Min Site";
  const html = `<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\" />
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />
    <title>${title}</title>
    <link rel=\"stylesheet\" href=\"styles.css\" />
  </head>
  <body>
    <header class=\"container\">
      <h1>${title}</h1>
      <p>Generated by 2 min site</p>
    </header>
    <main class=\"container\">
      <section class=\"card\">
        <h2>About</h2>
        <p>${safePrompt ||  "A fast starter site generated from your prompt."}</p>
      </section>
      <section class=\"grid\">
        <div class=\"card\"><h3>Feature One</h3><p>Clean, responsive layout.</p></div>
        <div class=\"card\"><h3>Feature Two</h3><p>Simple, portable files.</p></div>
        <div class=\"card\"><h3>Feature Three</h3><p>Ready to deploy anywhere.</p></div>
      </section>
    </main>
    <footer class=\"footer\">© ${new Date().getFullYear()} 2 min site</footer>
    <script src=\"script.js\"></script>
  </body>
</html>`;

  const css = `:root{--bg:#0b1020;--card:#121a33;--text:#e6ecff;--accent:#7aa2ff}
*{box-sizing:border-box}body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b1020,#0e1330);color:var(--text)}
.container{width:min(1100px,92vw);margin:0 auto;padding:24px}
header{padding:48px 0;text-align:center}
h1{margin:0 0 8px;font-size:clamp(28px,4vw,44px)}
p{opacity:.9}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:16px;margin:16px 0}
.card{background:var(--card);border:1px solid #1d2752;border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
.card h3{margin:0 0 8px;font-size:18px;color:var(--accent)}
.footer{padding:32px 0;text-align:center;opacity:.7;border-top:1px solid #1d2752;margin-top:24px}`;

  const js = `document.addEventListener('DOMContentLoaded',()=>{
  console.log('2 min site loaded');
});`;

  return { html, css, js }; 
}

function extractBody(htmlText) {
  const match = /<body[\s\S]*?>([\s\S]*?)<\/body>/i.exec(htmlText);
  return match ? match[1] : htmlText;
}
 
async function buildFromUrl(url) {
  const u = String(url || "").trim();
  if (!/^https?:\/\//i.test(u)) throw new Error("Invalid URL. Must start with http/https");

  const res = await fetch(u, { headers: { "User-Agent": "2minsite/1.0" } });
  if (!res.ok) throw new Error(`Failed to fetch URL: ${res.status}`);
  const text = await res.text();

  // naive extraction
  const titleMatch = text.match(/<title>([^<]*)<\/title>/i);
  const title = titleMatch ? titleMatch[1].slice(0, 100) : "Imported Site";
  const bodyInner = extractBody(text);

  const html = `<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\" />
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />
    <title>${title}</title>
    <link rel=\"stylesheet\" href=\"styles.css\" />
  </head>
  <body>
    <header class=\"container\"><h1>${title}</h1><p>Imported with 2 min site</p></header>
    <main class=\"container imported\">${bodyInner}</main>
    <footer class=\"footer\">© ${new Date().getFullYear()} 2 min site</footer>
    <script src=\"script.js\"></script>
  </body>
</html>`;

  const css = `body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0f1224;color:#e6ecff}
.container{width:min(1100px,92vw);margin:0 auto;padding:24px}
header{padding:36px 0;text-align:center}
.imported :where(script,style){display:none !important}
img,svg,video{max-width:100%;height:auto}
a{color:#9bb4ff}
.footer{padding:32px 0;text-align:center;opacity:.7;border-top:1px solid #1d2752;margin-top:24px}`;
  const js = `console.log('Imported site content rendered');`;

  return { html, css, js };
}

function parseBlocks(text) {
  const out = { html: "", css: "", js: "" };
  const rx = /```(html|css|js)[\s\S]*?\n([\s\S]*?)```/gi;
  let m;
  while ((m = rx.exec(text))) {
    const lang = m[1].toLowerCase();
    out[lang] = m[2].trim();
  }
  return out; 
} 

async function buildWithGemini(prompt) {
  const apiKey = process.env.GOOGLE_API_KEY;
  if (!apiKey) return null;
  const GoogleGenerativeAI = await getGoogleAI();
  if (!GoogleGenerativeAI) return null;

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

  const sys = `You are a web generator. Produce three code blocks: \n\n` +
    `1) \`\`\`html\n[ONLY the HTML body content or full HTML if needed]\n\`\`\`\n` +
    `2) \`\`\`css\n[All CSS]\n\`\`\`\n` +
    `3) \`\`\`js\n[All JS]\n\`\`\`\n` +
    `Constraints: Responsive, semantic, no external CDNs, no frameworks, reference styles via styles.css and script.js if using full HTML. Keep assets inline placeholders.`;

  const user = `Build a small, clean, responsive static website based on: "${String(prompt).slice(0, 2000)}".\n` +
    `Provide HTML/CSS/JS as separate fenced code blocks (html, css, js).`;

  const result = await model.generateContent([{ text: sys }, { text: user }]);
  const text = result?.response?.text?.() || "";
  const blocks = parseBlocks(text);

  let html = blocks.html || "";
  const hasDoctype = /<!doctype html>/i.test(html) || /<html[\s>]/i.test(html);
  if (!hasDoctype) {
    // Treat as body content; wrap to full HTML
    html = `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>2 min site</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n${html}\n    <script src=\"script.js\"></script>\n  </body>\n</html>`;
  } else {
    // Ensure stylesheet and script references exist
    if (!/styles\.css/.test(html)) html = html.replace(/<head>/i, '<head>\n    <link rel="stylesheet" href="styles.css" />');
    if (!/script\.js/.test(html)) html = html.replace(/<\/body>/i, '    <script src="script.js"></script>\n  </body>');
  }

  const css = blocks.css || "body{margin:0;font-family:system-ui,sans-serif;padding:24px}";
  const js = blocks.js || "console.log('Generated by 2 min site with Gemini');";
  return { html, css, js };
}

async function makeZip(files) {
  const JSZip = await getJSZip();
  if (!JSZip) return null;
  const zip = new JSZip();
  zip.file("index.html", files.html);
  zip.file("styles.css", files.css);
  zip.file("script.js", files.js);
  const content = await zip.generateAsync({ type: "base64" });
  return content; // base64 string
}

export async function POST(request) {
  try {
    const body = await request.json();
    const mode = body?.mode;
    const provider = body?.provider; // 'gemini' to force Gemini
    if (mode !== "prompt" && mode !== "url") {
      return NextResponse.json({ error: "mode must be 'prompt' or 'url'" }, { status: 400 });
    }

    let files;
    if (mode === "prompt") {
      if (!body?.prompt || String(body.prompt).trim().length < 3) {
        return NextResponse.json({ error: "prompt is required (min 3 chars)" }, { status: 400 });
      }
      // Prefer Gemini if requested and available, otherwise fallback
      if (provider === "gemini" || process.env.GOOGLE_API_KEY) {
        files = await buildWithGemini(body.prompt);
      }
      if (!files) {
        files = buildFromPrompt(body.prompt);
      }
    } else {
      if (!body?.url) {
        return NextResponse.json({ error: "url is required" }, { status: 400 });
      }
      files = await buildFromUrl(body.url);
    }

    const zipBase64 = await makeZip(files);
    return NextResponse.json({ ...files, zipBase64, filename: "2minsite.zip" });
  } catch (e) {
    return NextResponse.json({ error: e?.message || "Unknown error" }, { status: 500 });
  }
}
